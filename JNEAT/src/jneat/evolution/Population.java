/* Generated by Together */

package jneat.evolution;

import java.util.*;

import jneat.Neat;
import jneat.neuralNetwork.Genome;
import jneat.neuralNetwork.Innovation;
import jNeatCommon.*;

/** A Population is a group of Organisms including their species */
public class Population extends Neat {
	/** The organisms in the Population */
	public Vector<Organism> organisms;

	/** Species in the Population the species should comprise all the genomes */
	public Vector<Species> species;

	/** For holding the genetic innovations of the newest generation */
	Vector<Innovation> innovations = new Vector<Innovation>(1, 0);

	/** Current label number available for nodes */
	private int cur_node_id;

	/** Current number of innovation */
	private double cur_innov_num;

	/** The highest species number */
	int last_species;

	/** The last generation played */
	int final_gen;

	// Fitness Statistics

	/** the mean of fitness in current epoch */
	double mean_fitness;

	/** current variance in this epoch */
	double variance;

	/** Is a current standard deviation in current epoch */
	double standard_deviation;

	/**
	 * An integer that when above zero tells when the first winner appeared; the
	 * number is epoch number.
	 */
	int winnergen;

	/** maximum fitness. (is used for delta code and stagnation detection) */
	double highest_fitness;

	/** If too high, leads to delta coding process. */
	int highest_last_changed;

	/**
	 * Insert the method's description here. Creation date: (01/02/2002 9.48.44)
	 */
	public Population() {
	}

	/**
	 * STC Create population based on single starter genome
	 * 
	 * @param g
	 * @param size
	 */
	public Population(Genome g, int size) {
		winnergen = 0;
		highest_fitness = 0.0;
		highest_last_changed = 0;
		spawn(g, size);
	}

	/**
	 * DEPREICATED - USE POPULATION (String, boolean) INSTEAD Construct a
	 * population off of a generation file. Uses all individuals in the
	 * generation
	 */
	@Deprecated
	public Population(String xFileName) {
		createPopulation(xFileName, false);
	}

	/**
	 * Creates a population off of a generation file
	 * 
	 * @param xFileName
	 *            - Path to the generation file
	 * @param onlyUseWinners
	 *            - Used when deciding if the new population should only hold
	 *            winners from the generation
	 */
	public Population(String xFileName, boolean onlyUseWinners) {
		createPopulation(xFileName, onlyUseWinners);
	}

	/**
	 * Create a population off of a given generation file. Bases it on winners
	 * if onlyUseWinners = true
	 * 
	 * @param xFileName
	 * @param onlyUseWinners
	 */
	private void createPopulation(String xFileName, boolean onlyUseWinners) {
		StringTokenizer st;
		String xline;
		IOseq xFile;

		boolean xok = false;
		String curword;
		int idcheck = 0;

		Genome new_genome;

		organisms = new Vector<Organism>(10, 0);

		winnergen = 0;
		highest_fitness = 0.0;
		highest_last_changed = 0;
		cur_node_id = 0;
		cur_innov_num = 0.0;

		xFile = new IOseq(xFileName);
		boolean ret = xFile.IOseqOpenR();

		if (ret) {
			new StringBuffer("");
			StringBuffer tmp2 = new StringBuffer("");
			int status = 0;
			try {
				// System.out.println("  ..opened population file "+xFileName);
				xline = xFile.IOseqRead();
				while (xline != "EOF") {
					st = new StringTokenizer(xline);
					curword = st.nextToken();

					if (curword.equalsIgnoreCase("genomestart")) {
						if (status == 1) {
							status = 2;
						}
						curword = st.nextToken();
						idcheck = Integer.parseInt(curword);

						new_genome = new Genome(idcheck, xFile);
						new_genome.notes = tmp2.toString();

						if (onlyUseWinners) {
							if (xok) {
								organisms.add(new Organism(0, new_genome, 1));
								xok = false;
							}
						} else {
							organisms.add(new Organism(0, new_genome, 1));
						}

						if (cur_node_id < new_genome.get_last_node_id())
							cur_node_id = new_genome.get_last_node_id();

						if (cur_innov_num < new_genome.get_last_gene_innovnum())
							cur_innov_num = new_genome.get_last_gene_innovnum();
					} // End if (curword.equalsIgnoreCase("genomestart"))
					else if (curword.equals("/*")) {
						if (onlyUseWinners && xline.indexOf("WINNER") >= 0) {
							xok = true;
						}

						if (status == 0) {
							status = 1;
						}

						if (status == 2) {
							status = 1;
						}

						curword = st.nextToken();
						while (!curword.equals("*/")) {
							curword = st.nextToken();
						}
					} // End if(curword.equals("/*"))

					xline = xFile.IOseqRead();
				} // End (xline != "EOF")
			} // End try
			catch (Throwable e) {
				System.err.println(e + " : error during read " + xFileName);
			}

			xFile.IOseqCloseR();

			// Create species
			Speciator s = new Speciator();
			last_species = s.speciate(organisms, this);

		} // End if (ret)
	}

	/**
	 * Tries to modify the compatability threshold to keep the number of species
	 * constant at p_num_species_target set in the configuration file Source of
	 * code: http://www.cs.ucf.edu/~kstanley/neat.html Added by: STC
	 * 
	 * @param generation
	 */
	private void keepSpeciesConstant(int generation) {
		if (Neat.p_num_species_target > 0) {
			// We can try to keep the number of species constant at this number
			int num_species_target = Neat.p_num_species_target;
			int num_species = species.size();
			double compat_mod = 0.3; // Modify compat thresh to control
										// speciation

			// Keeping species diverse
			// This commented out code forces the system to aim for
			// num_species species at all times, enforcing diversity
			// This tinkers with the compatibility threshold, which
			// normally would be held constant
			if (generation > 1) {
				if (num_species < num_species_target) {
					Neat.p_compat_threshold -= compat_mod; // compat_mod works
															// well at about 0.3
				} else if (num_species > num_species_target) {
					Neat.p_compat_threshold += compat_mod;
				}
				if (Neat.p_compat_threshold < 0.3) {
					Neat.p_compat_threshold = 0.3;
				}
			}
		}
	}

	/***
	 * epoch turns over a Population to the next generation based on fitness
	 */
	public void epoch(int generation) {

		Iterator<Species> itr_specie;
		Iterator<Organism> itr_organism;
		double total = 0.0;
		int orgcount = 0;
		int max_expected;
		int total_expected; // precision checking
		int final_expected;
		double overall_average = 0.0;
		int total_organisms = 0;
		double skim = 0.0;
		int best_species_num = 0;
		int size_of_curr_specie = 0;
		Species _specie = null;
		Species bestSpecies = null;
		Species best_specie = null;
		Vector<Species> sorted_species = null;

		// Try to keep number of species constant
		keepSpeciesConstant(generation);

		// Use Species' ages to modify the objective fitness of organisms
		// in other words, make it more fair for younger species
		// so they have a chance to take hold
		// Also penalize stagnant species
		// Then adjust the fitness using the species size to "share" fitness
		// within a species.
		// Then, within each Species, mark for death
		// those below survival_thresh * average

		itr_specie = species.iterator();
		while (itr_specie.hasNext()) {
			_specie = ((Species) itr_specie.next());
			_specie.adjust_fitness();
			_specie.markForDeath();
		}

		// Go through all organisms in the population and add up their fitness
		// to compute the
		// overall average

		itr_organism = organisms.iterator();
		total = 0.0;
		while (itr_organism.hasNext()) {
			Organism _organism = ((Organism) itr_organism.next());
			total += _organism.fitness;
		}

		total_organisms = organisms.size();
		overall_average = total / total_organisms;

		// Now compute expected number of offspring for each individual organism
		//
		itr_organism = organisms.iterator();
		while (itr_organism.hasNext()) {
			Organism _organism = ((Organism) itr_organism.next());
			_organism.expected_offspring = _organism.fitness / overall_average;
		}

		// Now add those offspring up within each Species to get the number of
		// offspring per Species
		skim = 0.0;
		total_expected = 0;
		itr_specie = species.iterator();
		while (itr_specie.hasNext()) {
			_specie = ((Species) itr_specie.next());
			skim = _specie.count_offspring(skim);
			total_expected += _specie.expected_offspring;
		}

		// Need to make up for lost floating point precision in offspring
		// assignment
		// If we lost precision, give an extra baby to the best Species

		if (total_expected < total_organisms) {

			// Find the Species expecting the most
			max_expected = 0;
			final_expected = 0;
			itr_specie = species.iterator();

			while (itr_specie.hasNext()) {
				_specie = ((Species) itr_specie.next());
				if (_specie.expected_offspring >= max_expected) {
					max_expected = _specie.expected_offspring;
					best_specie = _specie;
				}
				final_expected += _specie.expected_offspring;
			}
			// Give the extra offspring to the best species

			best_specie.expected_offspring++;
			final_expected++;

			// If we still arent at total, there is a problem
			// Note that this can happen if a stagnant Species
			// dominates the population and then gets killed off by its age
			// Then the whole population plummets in fitness
			// If the average fitness is allowed to hit 0, then we no longer
			// have
			// an average we can use to assign offspring.
			if (final_expected < total_organisms) {
				System.out.print("\n Sorry : Population .has DIED +");
				System.out.print("\n ------------------------------");
				itr_specie = species.iterator();
				while (itr_specie.hasNext()) {
					_specie = ((Species) itr_specie.next());
					_specie.expected_offspring = 0;
				}
				best_specie.expected_offspring = total_organisms;
			}
		}

		// copy the Species pointers into a new Species list for sorting
		sorted_species = new Vector<Species>(species.size(), 0);
		itr_specie = species.iterator();
		while (itr_specie.hasNext()) {
			_specie = ((Species) itr_specie.next());
			sorted_species.add(_specie);
		}

		// Sort all species and find the best species
		// the species with orig_fitness maximum is first
		@SuppressWarnings("unchecked")
		Comparator<Species> cmp = new order_species();
		Collections.sort(sorted_species, cmp);
		bestSpecies = (Species) sorted_species.firstElement();
		best_species_num = bestSpecies.id;

		StringBuffer rep1 = new StringBuffer("");
		// System.out.print("\n  The BEST specie is #" + best_species_num);
		rep1.append("\n  the BEST  specie is #" + best_species_num);
		reportSituation(rep1, sorted_species);

		// Find population champ
		Organism popChamp = ((Organism) bestSpecies.getOrganisms()
				.firstElement());
		popChamp.pop_champ = true;

		// Check for Population-level stagnation
		if (popChamp.orig_fitness > highest_fitness) {
			// Fitness of the population has grown
			highest_fitness = popChamp.orig_fitness;
			highest_last_changed = 0;
			rep1.append("\n    population has reached a new *RECORD FITNESS* -> "
					+ highest_fitness);
		} else {
			// Fitness of population has not grown
			++highest_last_changed;
			rep1.append("\n    are passed " + highest_last_changed
					+ " generations from last population fitness record: "
					+ highest_fitness);
		}

		// Perform delta coding if there is stagnation. 
		//Otherwise steal babies (If set in config file)
		if (highest_last_changed >= Neat.p_dropoff_age + 5) {
			deltaCoding(sorted_species);
		} else if (Neat.p_babies_stolen > 0) {
				stealBabies(sorted_species);
		}
		
		//Eliminate organisms marked for elimination
		eliminateOrganisms();

		//Perform reproduction
		//Offspring is not added to the population (Organism list) yet
		itr_specie = sorted_species.iterator();
		while (itr_specie.hasNext()) {
			_specie = ((Species) itr_specie.next());
			_specie.reproduce(generation, this, sorted_species);
		}

		//Remove the parents from their species
		itr_organism = organisms.iterator();
		while (itr_organism.hasNext()) {
			Organism _organism = ((Organism) itr_organism.next());
			// Remove the organism from its Species
			_specie = _organism.species;
			_specie.remove_org(_organism);
		}
		
		//Remove parents from the population  list
		organisms.clear();

		// Remove all empty Species and age ones that survive
		// As this happens, create master organism list for the new generation
		itr_specie = species.iterator();
		Vector<Neat> vdel = new Vector<Neat>(species.size());
		orgcount = 0;

		while (itr_specie.hasNext()) {
			_specie = ((Species) itr_specie.next());
			size_of_curr_specie = _specie.organismsInSpecies.size();
			if (size_of_curr_specie == 0)
				vdel.add(_specie);
			else {
				// Age any Species that is not newly created in this generation
				if (_specie.novel) {
					_specie.novel = false;
				}
				else {
					_specie.age++;
				}
				// Add organisms from the current species to population organism list
				for (int j = 0; j < size_of_curr_specie; j++) {
					Organism _organism = (Organism) _specie.organismsInSpecies
							.elementAt(j);
					_organism.genome.setGenome_id(orgcount++);

					_organism.genome.getPhenotype().setNet_id(
							_organism.genome.getGenome_id());

					organisms.add(_organism);
				}
			}
		}

		// eliminate species marked from master list
		for (int i = 0; i < vdel.size(); i++) {
			_specie = (Species) vdel.elementAt(i);
			species.removeElement(_specie);
		}

		// Remove the innovations of the current generation
		innovations.clear();
		
		//STC: Changed from testing to see if best species is dead to see if pop_champ survived
		// DEBUG: Check to see if the best organism died somehow
		// We don't want this to happen
		if (!popChampChildIsAlive(best_species_num)){
			System.out.println("*********");
			System.out.println("!!!!! Oh no! The population champ's clone hasn't survived !!!!!");
			System.out.println("*********");
		}

	}
	
	private boolean popChampChildIsAlive(int best_species_num){
		Species bestSpecies = findBestSpecies(best_species_num);
		
		Iterator <Organism> itr_organism = bestSpecies.organismsInSpecies.iterator();

		while (itr_organism.hasNext()) {
			Organism _organism = ((Organism) itr_organism.next());
			if (_organism.pop_champ_child) {
				return true;
			}
		}		
		return false;
	}
	
	private Species findBestSpecies(int best_species_num){
		Iterator<Species> itr_specie = species.iterator();
		Species _specie = null;
		while (itr_specie.hasNext()) {
			_specie = ((Species) itr_specie.next());
			if (_specie.id == best_species_num) {
				return _specie;
			}
		}		
		return null;
	}
	
	

	/**
	 * Reports the current situation to rep1
	 * 
	 * @param rep1
	 * @param sorted_species
	 */
	private void reportSituation(StringBuffer rep1,
			Vector<Species> sorted_species) {
		Iterator<Species> itr_specie;
		Species _specie = null;

		itr_specie = sorted_species.iterator();
		while (itr_specie.hasNext()) {
			_specie = ((Species) itr_specie.next());
			// System.out.print("\n  orig fitness of Species #" + _specie.id);
			rep1.append("\n  orig fitness of Species #" + _specie.id);

			// System.out.print(" (Size " + _specie.getOrganisms().size() +
			// "): ");
			rep1.append(" (Size " + _specie.getOrganisms().size() + "): ");

			// System.out.print(" is " + ((Organism)
			// (_specie.organisms.firstElement())).orig_fitness);
			rep1.append(" is "
					+ ((Organism) (_specie.organismsInSpecies.firstElement())).orig_fitness);

			// System.out.print(" last improved ");
			rep1.append(" last improved ");

			// System.out.print(_specie.age - _specie.age_of_last_improvement);
			rep1.append(_specie.age - _specie.age_of_last_improvement);

			// System.out.print(" offspring "+_specie.expected_offspring);
			rep1.append(" offspring " + _specie.expected_offspring);

		}
	}

	/**
	 * Performs delta coding on a stagnant population
	 */
	private void deltaCoding(Vector<Species> sorted_species) {
		int half_pop = 0;
		int tmpi = 0;
		Iterator<Species> itr_specie;
		Species _specie = null;

		System.out.print("\n+  <PERFORMING DELTA CODING>");

		highest_last_changed = 0;
		half_pop = Neat.p_pop_size / 2;
		tmpi = Neat.p_pop_size - half_pop;

		System.out.print("\n  Pop size is " + Neat.p_pop_size);
		System.out.print(", half_pop=" + half_pop + ",   pop_size - halfpop="
				+ tmpi);

		itr_specie = sorted_species.iterator();
		_specie = ((Species) itr_specie.next());

		// the first organism of first species can have offspring = 1/2 pop
		// size
		((Organism) _specie.organismsInSpecies.firstElement()).super_champ_offspring = half_pop;

		// the first species can have offspring = 1/2 pop size
		_specie.expected_offspring = half_pop;
		_specie.age_of_last_improvement = _specie.age;

		if (itr_specie.hasNext()) {
			_specie = ((Species) itr_specie.next());
			((Organism) _specie.organismsInSpecies.firstElement()).super_champ_offspring = half_pop;

			// the second species can have offspring = 1/2 pop size
			_specie.expected_offspring = half_pop;
			_specie.age_of_last_improvement = _specie.age;

			// at this moment the offpring is terminated : the remainder
			// species has 0 offspring!
			while (itr_specie.hasNext()) {
				_specie = ((Species) itr_specie.next());
				_specie.expected_offspring = 0;
			} // Loop through remainding species
		} else {
			((Organism) _specie.organismsInSpecies.firstElement()).super_champ_offspring += Neat.p_pop_size
					- half_pop;
			_specie.expected_offspring += Neat.p_pop_size - half_pop;
		}
	}

	/**
	 * Sterals babies from lesser species
	 */
	private void stealBabies(Vector<Species> sorted_species) {
		Species _specie = null;
		int stolen_babies = 0;
		int NUM_STOLEN = Neat.p_babies_stolen;
		int tmpi = 0;
		
		// System.out.print("\n   Starting with NUM_STOLEN = "+NUM_STOLEN);

		// Take away a constant number of expected offspring from the
		// worst few species
		for (int j = sorted_species.size() - 1; (j >= 0)
				&& (stolen_babies < NUM_STOLEN); j--) {
			_specie = (Species) sorted_species.elementAt(j);
			// System.out.print("\n Analisis SPECIE #"+j+" (size = "+_specie.organisms.size()+" )");
			if ((_specie.age > 5) && (_specie.expected_offspring > 2)) {
				// System.out.print("\n ....STEALING!");
				tmpi = NUM_STOLEN - stolen_babies;
				if ((_specie.expected_offspring - 1) >= tmpi) {
					_specie.expected_offspring -= tmpi;
					stolen_babies = NUM_STOLEN;
				} else
				// Not enough here to complete the pool of stolen
				{
					stolen_babies += _specie.expected_offspring - 1;
					_specie.expected_offspring = 1;
				}
			}
		}
		// System.out.print("\n stolen babies = "+ stolen_babies);
		// Mark the best champions of the top species to be the super
		// champs
		// who will take on the extra offspring for cloning or mutant
		// cloning
		// Determine the exact number that will be given to the top
		// three
		// They get , in order, 1/5 1/5 and 1/10 of the stolen babies

		int tb_four[] = new int[3];
		tb_four[0] = Neat.p_babies_stolen / 5;
		tb_four[1] = tb_four[0];
		tb_four[2] = Neat.p_babies_stolen / 10;

		boolean done = false;
		Iterator<Species>itr_specie = sorted_species.iterator();
		int i_block = 0;

		while (!done && itr_specie.hasNext()) {
			_specie = ((Species) itr_specie.next());
			if (_specie.last_improved() <= Neat.p_dropoff_age) {
				if (i_block < 3) {
					if (stolen_babies >= tb_four[i_block]) {
						((Organism) _specie.organismsInSpecies.firstElement()).super_champ_offspring = tb_four[i_block];
						_specie.expected_offspring += tb_four[i_block];
						stolen_babies -= tb_four[i_block];
						System.out.print("\n  give " + tb_four[i_block]
								+ " babies to specie #" + _specie.id);
					}
					i_block++;
				} else if (i_block >= 3) {
					if (NeatRoutine.randfloat() > 0.1) {
						if (stolen_babies > 3) {
							((Organism) _specie.organismsInSpecies
									.firstElement()).super_champ_offspring = 3;
							_specie.expected_offspring += 3;
							stolen_babies -= 3;
							System.out.print("\n    Give 3 babies to Species "
									+ _specie.id);
						} else {
							((Organism) _specie.organismsInSpecies
									.firstElement()).super_champ_offspring = stolen_babies;
							_specie.expected_offspring += stolen_babies;
							System.out.print("\n    Give " + stolen_babies
									+ " babies to Species " + _specie.id);
							stolen_babies = 0;
						}
					}
					if (stolen_babies == 0)
						done = true;
				}
			}
		}

		if (stolen_babies > 0) {
			System.out.print("\n Not all given back, giving to best Species");
			itr_specie = sorted_species.iterator();
			_specie = ((Species) itr_specie.next());
			((Organism) _specie.organismsInSpecies.firstElement()).super_champ_offspring += stolen_babies;
			_specie.expected_offspring += stolen_babies;
			System.out.print("\n    force +" + stolen_babies
					+ " offspring to Species " + _specie.id);
			stolen_babies = 0;
		}

	}

	/**
	 * Eliminates organisms marked for elimination from their species and from the population (Organism list).
	 */
	private void eliminateOrganisms(){
		Species _specie = null;
		Iterator<Organism> itr_organism = organisms.iterator();
		Vector<Neat> vdel = new Vector<Neat>(organisms.size());
		
		// Removes organisms from species and adds them to 
		// the population elimination list
		while (itr_organism.hasNext()) {
			Organism _organism = ((Organism) itr_organism.next());
			if (_organism.eliminate) {
				// Remove the organism from its Species
				_specie = _organism.species;
				_specie.remove_org(_organism);
				// store the organism can be eliminated;
				vdel.add(_organism);
			}
		}
		
		// eliminate organism from population elimination list
		for (int i = 0; i < vdel.size(); i++) {
			Organism _organism = (Organism) vdel.elementAt(i);
			organisms.removeElement(_organism);
		}

		vdel.clear();
	}
	
	public double getCur_innov_num() {
		return cur_innov_num;
	}

	public int getCur_node_id() {
		return cur_node_id;
	}

	/**
	 * the increment of cur_node_id must be executed only from a method of
	 * population for security reason
	 */
	public int getCur_node_id_and_increment() {
		return cur_node_id++;
	}

	/**
	 * the increment of cur_innov_num must be executed only from a method of
	 * population for security reason
	 */

	public double getCurr_innov_num_and_increment() {
		return cur_innov_num++;
	}

	public int getFinal_gen() {
		return final_gen;
	}

	public double getHighest_fitness() {
		return highest_fitness;
	}

	public int getHighest_last_changed() {
		return highest_last_changed;
	}

	public Vector<Innovation> getInnovations() {
		return innovations;
	}

	public int getLast_species() {
		return last_species;
	}

	public double getMean_fitness() {
		return mean_fitness;
	}

	public Vector<Organism> getOrganisms() {
		return organisms;
	}

	public Vector<Species> getSpecies() {
		return species;
	}

	public double getStandard_deviation() {
		return standard_deviation;
	}

	public double getVariance() {
		return variance;
	}

	public int getWinnergen() {
		return winnergen;
	}

	public void incrementCur_innov_num() {
		cur_innov_num += 1;
	}

	public void incrementCur_node_id() {
		cur_node_id += 1;
	}

	public void print_to_file(IOseq xFile) {
		//
		// write to file genome in native format (for re-read)
		//

		Iterator<Organism> itr_organism;
		Organism _organism = null;

		itr_organism = organisms.iterator();

		while (itr_organism.hasNext()) {
			_organism = ((Organism) itr_organism.next());
			_organism.genome.print_to_file(xFile);
		}

	}

	public void print_to_file_by_species(String xNameFile) {
		//
		// write to file genome in native format (for re-read)
		//
		IOseq xFile;

		xFile = new IOseq(xNameFile);
		xFile.IOseqOpenW(false);

		try {

			Iterator<Species> itr_specie;
			itr_specie = species.iterator();

			while (itr_specie.hasNext()) {
				Species _specie = ((Species) itr_specie.next());
				_specie.print_to_file(xFile);
			}

		} catch (Throwable e) {
			System.err.println(e);
		}

		xFile.IOseqCloseW();

	}

	/**
	 * write genome to file in native format (for re-read)
	 * 
	 * @param xNameFile
	 */
	public void print_to_filename(String xNameFile) {
		//
		// write to file genome in native format (for re-read)
		//
		IOseq xFile;

		xFile = new IOseq(xNameFile);
		xFile.IOseqOpenW(false);

		try {
			print_to_file(xFile);
		} catch (Throwable e) {
			System.err.println(e);
		}

		xFile.IOseqCloseW();

	}

	public void setCur_innov_num(double cur_innov_num) {
		this.cur_innov_num = cur_innov_num;
	}

	public void setCur_node_id(int cur_node_id) {
		this.cur_node_id = cur_node_id;
	}

	public void setFinal_gen(int final_gen) {
		this.final_gen = final_gen;
	}

	public void setHighest_fitness(double highest_fitness) {
		this.highest_fitness = highest_fitness;
	}

	public void setHighest_last_changed(int highest_last_changed) {
		this.highest_last_changed = highest_last_changed;
	}

	public void setInnovations(Vector<Innovation> innovations) {
		this.innovations = innovations;
	}

	public void setLast_species(int last_species) {
		this.last_species = last_species;
	}

	public void setMean_fitness(double mean_fitness) {
		this.mean_fitness = mean_fitness;
	}

	public void setOrganisms(Vector<Organism> organisms) {
		this.organisms = organisms;
	}

	public void setSpecies(Vector<Species> species) {
		this.species = species;
	}

	public void setStandard_deviation(double standard_deviation) {
		this.standard_deviation = standard_deviation;
	}

	public void setVariance(double variance) {
		this.variance = variance;
	}

	public void setWinnergen(int winnergen) {
		this.winnergen = winnergen;
	}

	public void spawn(Genome g, int size) {
		int count;
		Genome newgenome = null;
		Organism neworganism = null;
		organisms = new Vector<Organism>(size);
		for (count = 1; count <= size; count++) {
			// System.out.print("\n Creating organism -> " + count);
			newgenome = g.duplicate(count);
			newgenome.mutate_link_weight(1.0, 1.0, NeatConstant.GAUSSIAN);
			neworganism = new Organism(0.0, newgenome, 1);
			organisms.add(neworganism);
		}

		// Keep a record of the innovation and node number we are on
		cur_node_id = newgenome.get_last_node_id();
		cur_innov_num = newgenome.get_last_gene_innovnum();

		// Separate the new Population into species
		Speciator s = new Speciator();
		last_species = s.speciate(organisms, this);
	}

	/**
	 * Debug Population Note: This checks each genome by verifying each one Only
	 * useful for debugging
	 */
	public void verify() {

		Iterator<Organism> itr_organism;
		Organism _organism = null;

		itr_organism = organisms.iterator();

		while (itr_organism.hasNext()) {
			_organism = ((Organism) itr_organism.next());
			_organism.genome.verify();
		}

	}

	/**
	   *
	   *
	   */
	public void viewtext() {

		System.out.print("\n\n\n\t\t *P O P U L A T I O N*");
		System.out.print("\n\n\t This population has " + organisms.size()
				+ " organisms, ");
		System.out.print(species.size() + " species :\n");
		Iterator<Organism> itr_organism = organisms.iterator();
		itr_organism = organisms.iterator();

		while (itr_organism.hasNext()) {
			Organism _organism = ((Organism) itr_organism.next());
			_organism.viewtext();
		}

		Iterator<Species> itr_specie = species.iterator();
		itr_specie = species.iterator();

		while (itr_specie.hasNext()) {
			Species _specie = ((Species) itr_specie.next());
			_specie.viewtext();
		}

	}
}